* nix-elisp-helpers
:PROPERTIES:
:TOC: :include siblings :depth 2 :ignore this
:END:
#+BEGIN_HTML
<a href="https://github.com/akirak/nix-elisp-helpers/actions">
<img src="https://github.com/akirak/nix-elisp-helpers/workflows/CI/badge.svg">
</a>
#+END_HTML

This repository provides some Nix functions for getting information of Emacs Lisp packages.
It uses [[https://github.com/talyz/fromElisp][talyz/fromElisp]] parser to parse S expressions.
:CONTENTS:
- [[#requirements][Requirements]]
- [[#installation][Installation]]
  - [[#flake][Flake]]
- [[#usage][Usage]]
  - [[#parsecask][parseCask]]
  - [[#parseelpapackages][parseElpaPackages]]
  - [[#parserecipe][parseRecipe]]
  - [[#fetchtreefromrecipe-and-flakerefattrsfromrecipe][fetchTreeFromRecipe and flakeRefAttrsFromRecipe]]
  - [[#expandpackagefiles][expandPackageFiles]]
  - [[#flakerefurlfromrecipe-and-flakerefurlfromflakerefattrs][flakeRefUrlFromRecipe and flakeRefUrlFromFlakeRefAttrs]]
- [[#details][Details]]
  - [[#supported-recipe-specs][Supported recipe specs]]
- [[#credits][Credits]]
:END:
** Features
This repository provides functions for parsing a Cask file, a MELPA-style recipe, and a package list on ELPA. Then you can use the parsing result to inspect dependencies, fetch the source repository, and generate a list of files of the package.

It also has good support for flake references. You can get a flake reference to the source repository of a package.
** Requirements
The fetch functions in this package requires Nix 2.4 or later.
** Installation
=default.nix= in this repository provides several functions for elisp development.
You can import the repository directly:

#+begin_src nix
  with (import (builtins.fetchGit {
    url = "https://github.com/akirak/nix-elisp-helpers.git";
    ref = "master";
    ...
  }));
#+end_src

Alternatively, you can use =niv= to add to your repository:

#+begin_src sh
niv add akirak/nix-elisp-helpers
#+end_src

#+begin_src nix
  with (import (import ./nix/sources.nix).nix-elisp-helpers { inherit pkgs; });
#+end_src
*** Flake
You can also use the functions via flake, but they are available under =lib.${system}= due to an indirect dependency on nixpkgs.
** Usage
*** Cask
**** Parsing a Cask file
=parseCask= function takes a =Cask= file content as an argument and returns the package data in an attribute set:

#+begin_src nix
let
  packageInfo = parseCask (builtins.readFile ./Cask)
in
  ...
#+end_src

=development.dependencies= holds all =depends-on= items in =development=, e.g.:

#+begin_src nix
  assert (builtins.map builtins.head packageInfo.development.dependencies ==
    ["f" "s" "dash" "ansi" "ecukes" "servant" "ert-runner" "el-mock" "noflet" "ert-async" "shell-split-string"]);
  ...
#+end_src
*** MELPA package
**** Supported recipe specs
:PROPERTIES:
:TOC: :ignore descendants
:END:
This library does not support 100% of [[https://github.com/melpa/melpa/#recipe-format][the recipe format]] supported by MELPA.
***** =:fetcher=
The following =:fetcher= types are generally supported: =github=, =gitlab=, and =git=. =hg= may not be supported.
***** =:url=
=:url= is supported when you use =git= fetcher.
***** =:repo=
=:repo= is supported when you use one of =github= and =gitlab= fetcher types.
***** =:branch=
=:branch= is supported.
***** =:version-regexp=
=:version-regexp= is not supported. Maybe coming soon.
***** =:commit=
=:commit= is supported.
***** =:files=
=:files= is supported.
**** Parsing a MELPA recipe
=parseRecipe= function takess a MELPA-style recipe string as an argument and returns its content as an attribute set:

#+begin_src nix
  # The file contains '(smex :repo "nonsequitur/smex" :fetcher github)'
  let
    package = parseRecipe (builtins.readFile ./smex);
  in
  ...
#+end_src

It's handy because it returns an attribute set:

#+begin_src nix
  assert (package.ename == "smex");
  assert (package.repo == "nonsequitur/smex");
  assert (package.fetcher == "github");
  assert (package.files == null);
  ...
#+end_src
**** Converting a MELPA recipe to a flake reference
=fetchTreeFromRecipe= function takes a string or attribute set for a MELPA-style recipe and fetches a snapshot of the source repository of the package.
The snapshot is stored in Nix, and the store path is returned.

#+begin_src nix
  fetchTreeFromRecipe (builtins.readFile ./my-package-recipe)
#+end_src

#+begin_src nix
  let
    recipe = ./dash;
    src = fetchTreeFromRecipe (builtins.readFile recipe);
  in
  pkgs.emacsPackages.melpaBuild {
    pname = "dash";
    version = "2.15";
    # The remote source is used
    inherit src recipe;
    ...
  }
#+end_src

Note that this function does not work in pure evaluation mode.

You can also use =flakeRefAttrsFromRecipe= function to retrieve an attribute set that can be passed to =builtins.fetchTree= function which is available since Nix 2.4.

Note: Nixpkgs includes an equivalent function in =pkgs/applications/editors/emacs/elixp-packages/libgenerated.nix=.

=flakeRefUrlFromRecipe= function takes a recipe string as an argument and returns a URL-like [[https://nixos.org/manual/nix/unstable/command-ref/new-cli/nix3-flake.html#flake-references][flake reference]]:

#+begin_src nix
  let
    recipe = ''
      (smex :repo "nonsequitur/smex" :fetcher github)
    '';
  in
  assert (flakeRefUrlFromRecipe recipe == "github:nonsequitur/smex");
  ...
#+end_src

Note that this function may not completely support all of the reference specs.

**** Expanding the files spec a MELPA recipe
=expandPackageFiles= function expands =:files= spec in a recipe under a given directory:

#+begin_src nix
  expandPackageFiles ./. ["*.el" [":excludes" ".dir-locals.el" "*-test.el"]]
#+end_src

It returns a list of matching files relative from the directory:

#+begin_src nix
  ["hello.el" "hello-utils.el"]
#+end_src

The first argument must be a path to a directory, and the second argument can be either a list or =null=. When =null= is given as a spec, the default spec of MELPA is used.

It can be combined with =parseRecipe=:

#+begin_src nix
  let
    package = parseRecipe (builtins.readFile ./awesome-package);
    files = expandPackageFiles ./. package.files;
  in
  assert (files == ["awesome-package.el" "awesome-package-utils.el"]);
  ...
#+end_src
*** ELPA packages
**** Parsing an ELPA package list
Parse an ELPA-style package list ([[https://git.savannah.gnu.org/cgit/emacs/elpa.git/plain/elpa-packages][example]]) and returns an attribute set.

#+begin_src nix
packages = parseElpaPackages (builtins.readFile ./elpa-packages)
#+end_src

Each value in the attribute set (which should be originally a plist) is converted to an attribute set:

#+begin_src nix
  assert (packages.ztree.url == "https://github.com/fourier/ztree");
  ...
#+end_src
**** Converting an ELPA package entry to a flake reference
=flakeRefAttrsFromElpaAttrs= takes an attribute set from a value in the result of =parseElpaPackages= and returns an attribute set that can be passed to =builtins.fetchTree=:

#+begin_src nix
  let
    packages = parseElpaPackages (builtins.readFile ./elpa-packages);
  in
  builtins.fetchTree (flakeRefAttrsFromElpaAttrs {} packages.ztree)
#+end_src

The first argument is an attribute set which can consist of the following options:

- If =preferReleaseBranch= is true, =:release-branch= is chosen as the branch if there is one.
*** Other utility functions
**** Converting a flake reference to another representation
=flakeRefUrlFromFlakeRefAttrs= converts an attribute set to its equivalent URL-style representation.
** Credits
This project uses [[https://github.com/talyz/fromElisp][talyz/fromElisp]] for parsing Emacs Lisp expressions in Nix.

